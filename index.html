<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gelişmiş 2048 Oyunu (Bitir Butonlu, Eski Oyun Listesi)</title>
  <style>
    /* === Temel Tema Değişkenleri === */
    :root {
      --bg-color: #faf8ef;
      --text-color: #776e65;
      --board-bg: #bbada0;
      --grid-cell-bg: #cdc1b4;
      --gap: 10px;
      --cell-size: 80px;
      /* Taş renkleri */
      --tile-2: #eee4da;
      --tile-4: #ede0c8;
      --tile-8: #f2b179;
      --tile-16: #f59563;
      --tile-32: #f67c5f;
      --tile-64: #f65e3b;
      --tile-128: #edcf72;
      --tile-256: #edcc61;
      --tile-512: #edc850;
      --tile-1024: #edc53f;
      --tile-2048: #edc22e;
      /* Animasyon süresi */
      --anim-duration: 0.2s;
    }
    .dark-theme {
      --bg-color: #181818;
      --text-color: #f9f6f2;
      --board-bg: #3e3e3e;
      --grid-cell-bg: #4a4a4a;
    }
    /* === Genel Stil === */
    body {
      margin: 0;
      padding: 20px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      position: relative;
    }
    h1 {
      margin-bottom: 5px;
    }
    /* Üst menü */
    #top-bar {
      width: 100%;
      max-width: 500px;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    #top-bar > * {
      margin: 5px;
    }
    button {
      padding: 8px 12px;
      font-size: 14px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background-color: #8f7a66;
      color: #f9f6f2;
      transition: background-color 0.2s;
    }
    button:hover {
      background-color: #a0897b;
    }
    select, input[type="number"] {
      padding: 6px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    /* === Oyun Alanı === */
    #board-container {
      position: relative;
      margin-bottom: 15px;
      /* Genişlik/yükseklik dinamik olarak ayarlanacak */
      touch-action: none; /* Dokunmatik varsayılan davranışlarını engelle */
    }
    /* Arka plan grid’i */
    #grid-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: var(--board-bg);
      border-radius: 10px;
      display: grid;
      gap: var(--gap);
      padding: var(--gap);
    }
    .grid-cell {
      background-color: var(--grid-cell-bg);
      width: var(--cell-size);
      height: var(--cell-size);
      border-radius: 5px;
    }
    /* Taşların container’ı (sadece taşlar hareket eder) */
    #tile-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      transition: transform var(--anim-duration) ease-out;
    }
    /* === Taş Stilleri ve Animasyonlar === */
    .tile {
      position: absolute;
      width: var(--cell-size);
      height: var(--cell-size);
      border-radius: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 24px;
      transition: all var(--anim-duration) ease-out;
    }
    .tile-new {
      animation: tile-appear 0.3s ease-out;
    }
    .tile-merge {
      animation: tile-merge 0.3s ease-out;
    }
    @keyframes tile-appear {
      from { transform: scale(0); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }
    @keyframes tile-merge {
      0% { transform: scale(1); }
      50% { transform: scale(1.3); }
      100% { transform: scale(1); }
    }
    /* Taş renkleri */
    .tile-2 { background-color: var(--tile-2); color: var(--text-color); }
    .tile-4 { background-color: var(--tile-4); color: var(--text-color); }
    .tile-8 { background-color: var(--tile-8); color: #f9f6f2; }
    .tile-16 { background-color: var(--tile-16); color: #f9f6f2; }
    .tile-32 { background-color: var(--tile-32); color: #f9f6f2; }
    .tile-64 { background-color: var(--tile-64); color: #f9f6f2; }
    .tile-128 { background-color: var(--tile-128); color: #f9f6f2; font-size: 20px; }
    .tile-256 { background-color: var(--tile-256); color: #f9f6f2; font-size: 20px; }
    .tile-512 { background-color: var(--tile-512); color: #f9f6f2; font-size: 20px; }
    .tile-1024 { background-color: var(--tile-1024); color: #f9f6f2; font-size: 18px; }
    .tile-2048 { background-color: var(--tile-2048); color: #f9f6f2; font-size: 18px; }
    /* === Skor ve Rekor Paneli === */
    #score-panel, #records-panel {
      width: 100%;
      max-width: 500px;
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      font-size: 16px;
    }
    #records-panel div {
      text-align: center;
      flex: 1;
    }
    /* === Eski Oyunlar Listesi === */
    #past-games {
      width: 100%;
      max-width: 500px;
      margin-top: 15px;
      border-top: 1px solid #ccc;
      padding-top: 10px;
      font-size: 14px;
    }
    #past-games h3 {
      margin: 0 0 5px;
      text-align: center;
    }
    #past-games ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    #past-games li {
      border-bottom: 1px solid #ddd;
      padding: 4px 0;
      display: flex;
      justify-content: space-between;
    }
    /* === Toast Bildirim Stilleri === */
    #toast-container {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      pointer-events: none;
    }
    .toast {
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 10px 20px;
      border-radius: 4px;
      margin-top: 5px;
      opacity: 0;
      animation: fadein 0.4s forwards, fadeout 0.4s forwards 2.5s;
    }
    @keyframes fadein {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes fadeout {
      from { opacity: 1; transform: translateY(0); }
      to { opacity: 0; transform: translateY(20px); }
    }
  </style>
</head>
<body>
  <h1>2048 Oyunu</h1>
  <!-- Üst menü: Tema, grid boyutu, zorluk seçimi, yeni oyun & oyunu bitir butonları -->
  <div id="top-bar">
    <button id="toggle-theme">Tema Değiştir</button>
    <div>
      <label for="gridSize">Grid: </label>
      <select id="gridSize">
        <option value="3">3×3</option>
        <option value="4" selected>4×4</option>
        <option value="5">5×5</option>
      </select>
    </div>
    <div>
      <label for="difficulty">Zorluk: </label>
      <select id="difficulty">
        <option value="easy" selected>Kolay</option>
        <option value="medium">Orta</option>
        <option value="hard">Zor</option>
      </select>
    </div>
    <div>
      <button id="startButton">Yeni Oyun</button>
      <button id="endGameButton">Oyunu Bitir</button>
    </div>
  </div>

  <!-- Skor Paneli -->
  <div id="score-panel">
    <div>Skor: <span id="score">0</span></div>
    <div>Son Oyun: <span id="lastScore">0</span></div>
  </div>
  <!-- Rekor Paneli: All-Time, Aylık, Haftalık, Günlük -->
  <div id="records-panel">
    <div>
      <strong>All-Time</strong>
      <div id="allTimeRecord">0</div>
    </div>
    <div>
      <strong>Aylık</strong>
      <div id="monthlyRecord">0</div>
    </div>
    <div>
      <strong>Haftalık</strong>
      <div id="weeklyRecord">0</div>
    </div>
    <div>
      <strong>Günlük</strong>
      <div id="dailyRecord">0</div>
    </div>
  </div>

  <!-- Oyun Alanı -->
  <div id="board-container">
    <div id="grid-container"></div>
    <div id="tile-container"></div>
  </div>

  <!-- Toast Bildirim Container -->
  <div id="toast-container"></div>

  <!-- Eski Oyunlar Listesi -->
  <div id="past-games">
    <h3>Geçmiş Oyunlar</h3>
    <ul id="pastGamesList"></ul>
  </div>

  <script>
    /* --- LocalStorage ile skor ve oyun durumunun yönetimi --- */
    const STORAGE_KEY_SCORES = 'gameScores';
    const STORAGE_KEY_STATE  = 'currentGameState';

    function loadScores() {
      const data = localStorage.getItem(STORAGE_KEY_SCORES);
      return data ? JSON.parse(data) : [];
    }

    function saveScore(score) {
      const scores = loadScores();
      scores.push({ score, time: Date.now() });
      localStorage.setItem(STORAGE_KEY_SCORES, JSON.stringify(scores));
      updatePastGamesUI();
    }

    function getRecords() {
      const scores = loadScores();
      const now = Date.now();
      const oneDay = 24 * 60 * 60 * 1000;
      const oneWeek = 7 * 24 * 60 * 60 * 1000;
      const oneMonth = 30 * 24 * 60 * 60 * 1000;
      let allTime = 0, daily = 0, weekly = 0, monthly = 0;
      scores.forEach(item => {
        allTime = Math.max(allTime, item.score);
        if (now - item.time <= oneDay) {
          daily = Math.max(daily, item.score);
        }
        if (now - item.time <= oneWeek) {
          weekly = Math.max(weekly, item.score);
        }
        if (now - item.time <= oneMonth) {
          monthly = Math.max(monthly, item.score);
        }
      });
      return { allTime, daily, weekly, monthly };
    }

    function updateRecordsUI() {
      const rec = getRecords();
      document.getElementById('allTimeRecord').textContent = rec.allTime;
      document.getElementById('monthlyRecord').textContent = rec.monthly;
      document.getElementById('weeklyRecord').textContent = rec.weekly;
      document.getElementById('dailyRecord').textContent = rec.daily;
    }

    function updatePastGamesUI() {
      const scores = loadScores();
      const list = document.getElementById("pastGamesList");
      list.innerHTML = "";
      // En yeni skorları yukarıya getirecek şekilde sıralayalım
      scores.sort((a, b) => b.time - a.time);
      scores.forEach(item => {
        const li = document.createElement("li");
        const date = new Date(item.time);
        li.textContent = `${date.toLocaleString()} - Skor: ${item.score}`;
        list.appendChild(li);
      });
    }

    // --- Toast Bildirim Fonksiyonu ---
    function showToast(message) {
      const container = document.getElementById("toast-container");
      const toast = document.createElement("div");
      toast.className = "toast";
      toast.textContent = message;
      container.appendChild(toast);
      setTimeout(() => {
        container.removeChild(toast);
      }, 3000);
    }

    /* --- Oyun Sınıfı --- */
    class Game2048 {
      constructor(size, difficulty, boardContainer, gridContainer, tileContainer, scoreEl, lastScoreEl, savedState = null) {
        this.size = size;
        this.difficulty = difficulty;
        this.boardContainer = boardContainer;
        this.gridContainer = gridContainer;
        this.tileContainer = tileContainer;
        this.scoreEl = scoreEl;
        this.lastScoreEl = lastScoreEl;
        this.dragging = false;
        this.dragStart = null;
        this.currentDragOffset = { x: 0, y: 0 };
        this.gameEnded = false;
        // Zorluk ayarları
        if (this.difficulty === 'easy') {
          this.startTiles = 2;
          this.prob2 = 0.9;
        } else if (this.difficulty === 'medium') {
          this.startTiles = 3;
          this.prob2 = 0.8;
        } else { // hard
          this.startTiles = 4;
          this.prob2 = 0.7;
        }
        if (savedState) {
          this.loadState(savedState);
        } else {
          this.score = 0;
          this.setupBoard();
          this.setupGrid();
          for (let i = 0; i < this.startTiles; i++) {
            this.addRandomTile();
          }
        }
        this.renderTiles();
        this.updateScore();
      }
      
      setupBoard() {
        this.board = [];
        for (let i = 0; i < this.size; i++) {
          let row = [];
          for (let j = 0; j < this.size; j++) {
            row.push(0);
          }
          this.board.push(row);
        }
      }
      
      setupGrid() {
        const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size'));
        const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap'));
        const boardSize = this.size * cellSize + (this.size + 1) * gap;
        this.boardContainer.style.width = boardSize + "px";
        this.boardContainer.style.height = boardSize + "px";
        this.gridContainer.style.gridTemplateColumns = `repeat(${this.size}, ${cellSize}px)`;
        this.gridContainer.innerHTML = "";
        for (let i = 0; i < this.size * this.size; i++) {
          const cell = document.createElement("div");
          cell.classList.add("grid-cell");
          this.gridContainer.appendChild(cell);
        }
      }
      
      addRandomTile() {
        let empty = [];
        for (let i = 0; i < this.size; i++) {
          for (let j = 0; j < this.size; j++) {
            if (this.board[i][j] === 0) empty.push({ r: i, c: j });
          }
        }
        if (!empty.length) return;
        const pos = empty[Math.floor(Math.random() * empty.length)];
        this.board[pos.r][pos.c] = Math.random() < this.prob2 ? 2 : 4;
      }
      
      updateScore() {
        this.scoreEl.textContent = this.score;
      }
      
      bindEvents() {
        document.addEventListener("keydown", (e) => {
          if (this.dragging || this.gameEnded) return;
          switch(e.key) {
            case "ArrowLeft":
            case "a":
            case "A":
              this.move("left");
              break;
            case "ArrowRight":
            case "d":
            case "D":
              this.move("right");
              break;
            case "ArrowUp":
            case "w":
            case "W":
              this.move("up");
              break;
            case "ArrowDown":
            case "s":
            case "S":
              this.move("down");
              break;
          }
        });
        // Dokunmatik hareket kontrolleri
        this.boardContainer.addEventListener("touchstart", (evt) => {
          if (evt.touches.length !== 1 || this.gameEnded) return;
          this.dragging = true;
          const touch = evt.touches[0];
          this.dragStart = { x: touch.clientX, y: touch.clientY };
        }, false);
        this.boardContainer.addEventListener("touchmove", (evt) => {
          if (!this.dragging || evt.touches.length !== 1) return;
          const touch = evt.touches[0];
          let dx = touch.clientX - this.dragStart.x;
          let dy = touch.clientY - this.dragStart.y;
          if (Math.abs(dx) > Math.abs(dy)) {
            dx = Math.max(Math.min(dx, 50), -50);
            dy = 0;
          } else {
            dy = Math.max(Math.min(dy, 50), -50);
            dx = 0;
          }
          this.currentDragOffset = { x: dx, y: dy };
          this.tileContainer.style.transform = `translate(${dx}px, ${dy}px)`;
          evt.preventDefault();
        }, { passive: false });
        this.boardContainer.addEventListener("touchend", (evt) => {
          if (!this.dragging) return;
          this.dragging = false;
          const threshold = 20;
          let direction = null;
          if (Math.abs(this.currentDragOffset.x) > Math.abs(this.currentDragOffset.y)) {
            if (this.currentDragOffset.x > threshold) direction = "right";
            else if (this.currentDragOffset.x < -threshold) direction = "left";
          } else {
            if (this.currentDragOffset.y > threshold) direction = "down";
            else if (this.currentDragOffset.y < -threshold) direction = "up";
          }
          if (direction) this.move(direction);
          this.tileContainer.style.transform = "translate(0,0)";
          this.currentDragOffset = { x: 0, y: 0 };
        }, false);
      }
      
      move(direction) {
        if (this.gameEnded) return;
        this.previousBoard = JSON.parse(JSON.stringify(this.board));
        let moved = false;
        switch(direction) {
          case "left":
            for (let i = 0; i < this.size; i++) {
              let newRow = this.slideAndCombine(this.board[i]);
              this.board[i] = newRow;
            }
            break;
          case "right":
            for (let i = 0; i < this.size; i++) {
              let row = this.board[i].slice().reverse();
              let newRow = this.slideAndCombine(row).reverse();
              this.board[i] = newRow;
            }
            break;
          case "up":
            for (let j = 0; j < this.size; j++) {
              let col = [];
              for (let i = 0; i < this.size; i++) {
                col.push(this.board[i][j]);
              }
              let newCol = this.slideAndCombine(col);
              for (let i = 0; i < this.size; i++) {
                this.board[i][j] = newCol[i];
              }
            }
            break;
          case "down":
            for (let j = 0; j < this.size; j++) {
              let col = [];
              for (let i = this.size - 1; i >= 0; i--) {
                col.push(this.board[i][j]);
              }
              let newCol = this.slideAndCombine(col).reverse();
              for (let i = 0; i < this.size; i++) {
                this.board[i][j] = newCol[i];
              }
            }
            break;
        }
        if (JSON.stringify(this.previousBoard) !== JSON.stringify(this.board)) {
          moved = true;
        }
        if (moved) {
          this.addRandomTile();
          this.renderTiles();
          this.updateScore();
          this.saveState();
          if (this.checkGameOver()) {
            setTimeout(() => {
              showToast("Oyun Bitti! Skor: " + this.score);
              this.lastScoreEl.textContent = this.score;
              saveScore(this.score);
              updateRecordsUI();
              localStorage.removeItem(STORAGE_KEY_STATE);
              this.gameEnded = true;
            }, 200);
          }
        }
      }
      
      slideAndCombine(array) {
        let filtered = array.filter(val => val !== 0);
        for (let i = 0; i < filtered.length - 1; i++) {
          if (filtered[i] === filtered[i+1]) {
            filtered[i] *= 2;
            this.score += filtered[i];
            filtered[i+1] = 0;
            i++;
          }
        }
        let newArray = filtered.filter(val => val !== 0);
        while(newArray.length < this.size) {
          newArray.push(0);
        }
        return newArray;
      }
      
      checkGameOver() {
        for (let i = 0; i < this.size; i++) {
          for (let j = 0; j < this.size; j++) {
            if (this.board[i][j] === 0) return false;
            if (j < this.size - 1 && this.board[i][j] === this.board[i][j+1]) return false;
            if (i < this.size - 1 && this.board[i][j] === this.board[i+1][j]) return false;
          }
        }
        return true;
      }
      
      renderTiles() {
        this.tileContainer.innerHTML = "";
        const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size'));
        const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap'));
        for (let i = 0; i < this.size; i++) {
          for (let j = 0; j < this.size; j++) {
            if (this.board[i][j] !== 0) {
              const tile = document.createElement("div");
              tile.classList.add("tile", "tile-" + this.board[i][j]);
              tile.textContent = this.board[i][j];
              const left = gap + j * (cellSize + gap);
              const top = gap + i * (cellSize + gap);
              tile.style.left = left + "px";
              tile.style.top = top + "px";
              let prevVal = (this.previousBoard && this.previousBoard[i] ? this.previousBoard[i][j] : 0) || 0;
              if (prevVal === 0) {
                tile.classList.add("tile-new");
              } else if (prevVal * 2 === this.board[i][j]) {
                tile.classList.add("tile-merge");
              }
              this.tileContainer.appendChild(tile);
            }
          }
        }
      }
      
      saveState() {
        const state = {
          size: this.size,
          difficulty: this.difficulty,
          board: this.board,
          score: this.score,
          startTiles: this.startTiles
        };
        localStorage.setItem(STORAGE_KEY_STATE, JSON.stringify(state));
      }
      
      loadState(savedState) {
        this.size = savedState.size;
        this.difficulty = savedState.difficulty;
        this.startTiles = savedState.startTiles;
        this.board = savedState.board;
        this.score = savedState.score;
        this.setupGrid();
      }
      
      endGame() {
        if (this.gameEnded) return;
        showToast("Oyunu Bitirdiniz! Skor: " + this.score);
        this.lastScoreEl.textContent = this.score;
        saveScore(this.score);
        updateRecordsUI();
        localStorage.removeItem(STORAGE_KEY_STATE);
        this.gameEnded = true;
      }
    }

    /* --- Başlat ve Tema Değiştirme İşlemleri --- */
    let game;
    function startNewGame() {
      const gridSelect = document.getElementById("gridSize");
      const difficultySelect = document.getElementById("difficulty");
      const size = parseInt(gridSelect.value);
      const difficulty = difficultySelect.value;
      const boardContainer = document.getElementById("board-container");
      const gridContainer = document.getElementById("grid-container");
      const tileContainer = document.getElementById("tile-container");
      const scoreEl = document.getElementById("score");
      const lastScoreEl = document.getElementById("lastScore");
      localStorage.removeItem(STORAGE_KEY_STATE);
      game = new Game2048(size, difficulty, boardContainer, gridContainer, tileContainer, scoreEl, lastScoreEl);
      game.bindEvents();
    }
    function loadSavedGame() {
      const saved = localStorage.getItem(STORAGE_KEY_STATE);
      if (saved) {
        const state = JSON.parse(saved);
        document.getElementById("gridSize").value = state.size;
        document.getElementById("difficulty").value = state.difficulty;
        const boardContainer = document.getElementById("board-container");
        const gridContainer = document.getElementById("grid-container");
        const tileContainer = document.getElementById("tile-container");
        const scoreEl = document.getElementById("score");
        const lastScoreEl = document.getElementById("lastScore");
        game = new Game2048(state.size, state.difficulty, boardContainer, gridContainer, tileContainer, scoreEl, lastScoreEl, state);
        game.bindEvents();
      }
    }
    
    document.getElementById("startButton").addEventListener("click", () => {
      startNewGame();
    });
    document.getElementById("endGameButton").addEventListener("click", () => {
      if (game) {
        game.endGame();
      } else {
        showToast("Oyun başlamamış!");
      }
    });
    document.getElementById("toggle-theme").addEventListener("click", () => {
      document.body.classList.toggle("dark-theme");
    });
    
    /* --- İlk Yüklemede: Eğer kayıtlı oyun varsa, kaldığınız yerden devam edelim --- */
    window.addEventListener("load", () => {
      updateRecordsUI();
      updatePastGamesUI();
      const savedGame = localStorage.getItem(STORAGE_KEY_STATE);
      if (savedGame) {
        loadSavedGame();
      }
    });
  </script>
</body>
</html>
